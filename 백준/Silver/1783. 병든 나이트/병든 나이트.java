

/*
[백준]
1783, 병든 나이트

[문제파악]
병든 나이트가 N × M 크기 체스판의 가장 왼쪽아래 칸에 위치해 있다.
병든 나이트는 건강한 보통 체스의 나이트와 다르게 4가지로만 움직일 수 있다.
    (1) 2칸 위로, 1칸 오른쪽
    (2) 1칸 위로, 2칸 오른쪽
    (3) 1칸 아래로, 2칸 오른쪽
    (4) 2칸 아래로, 1칸 오른쪽
병든 나이트는 여행을 시작하려고 하고, 여행을 하면서 방문한 칸의 수를 최대로 하려고 한다.
병든 나이트의 이동 횟수가 4번보다 적지 않다면, 이동 방법을 모두 한 번씩 사용해야 한다.
이동 횟수가 4번보다 적은 경우(방문한 칸이 5개 미만)에는 이동 방법에 대한 제약이 없다.

체스판의 크기가 주어졌을 때, 병든 나이트가 여행에서 방문할 수 있는 칸의 최대 개수를 구해보자.

[입력]
첫째 줄에 체스판의 세로 길이 N와 가로 길이 M이 주어진다. N과 M은 2,000,000,000보다 작거나 같은 자연수이다.

[출력]
병든 나이트가 여행에서 방문할 수 있는 칸의 개수중 최댓값을 출력한다.

[구현방법]
- 결국 이동 횟수가 4이하일 때는 맘대로 이동해도 되고, 이동 횟수가 4를 초과하는 시점부턴 이동방법을 모두 한번씩은 적용(사이클)해야함을 의미한다
- 그럼 앞에 4회의 이동횟수를 4!의 조건으로 모두 탐색해야하나? (체스판 범위 밖을 넘치지 않는 조건만 골라서 진행하면 될지도?)
- 그럼 그 이후엔? 현 상황에서 4가지 이동 조건 중 가능한 조건들로 탐색? BFS로?
- 근데 그럼 이게 고작 S3이라고...? 뭔가 좀 복잡한 것 같은데 더 쉬운게 있으니 이 난이도에 있는거 아닌가
- 단순화 하면 그냥 현재 상황에 되는대로 골라잡아서 이동하는 것이다 4이하까지는.
- 그리고 5번째 이동할 칸부터는 현재 조건에서 되는 것을 골라서 4개의 이동의 isUsed를 체크해가며 이동
- 4개를 다 쓸 때까지 문제 없었으면 isUsed 초기화
- 위 과정 반복
- 근데 문제 조건이 [N과 M은 2,000,000,000보다 작거나 같은 자연수]인데 누가 봐도 BFS로 절대 2초 안에 못푼다 아닙니까? ㅋㅋ
- 흠...

- 아 이거 패턴 & 시뮬 문제란다..;;; 어쩐지
- N, M 크기에 따라 경우를 분기해서 답을 도출해야함
- 이동은 오른쪽으로만 진행 가능하므로, 사실상 “세로 방향(N)”이 얼마나 되는지가 제약을 만듦
- 결국 가로 길이(M)에 따라 케이스를 나누느것이 중요하다

- N == 1 : 1칸 이동가능
- N == 2 : 2칸 이동 가능
    - 정확히는 min(4, (M + 1) / 2)이다
    - 4칸 이하는 맘대로 이동할 수 있으니까 N의 높이에 따라 다름
- N == 3
    - [이하 조건들은 시작이 1열이기 떄문에 7이 기준이 되는 것이다]
    - M < 7 : 4가지 이동 다 못씀
        - 방문 칸수는 M에 달렸으나, 4칸 이하는 맘대로 움직일 수 있으니 최소 4칸은 확보됨
        - 결과적으로 min(4, M)
        - 물론 M이 4보다 작을 가능성 또한 배제는 불가능 (그래서 min값으로 측정)
    - 7 <= M : 제약없이 이동 가능
        - 방문칸수 = M - 2
        - 조건 4개중 오른쪽으로 2칸씩 건너뛰는게 2개 있다
        - 그로인해 한사이클을 소비하는데 필요한 총 칸의 갯수는 6
        - But, 정작 갈 수 있는 칸의 갯수는 4칸이라 -2를 하는 것

- 이거 그대로 코드로 옮기면 됨
- 언제쯤 문제를 쉽게 생각하고 단순화하는게 빨라지는건지 ^^ (어쩌면 문제를 너무 대충 읽는건 아닐까..?;;)

[보완점]

*/

import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());

        int result;

        if (N == 1) result = 1;
        else if (N == 2) result = Math.min(4, (M + 1) / 2);
        else {
            if (M < 7) result = Math.min(4, M);
            else result = M - 2;
        }

        System.out.println(result);
    }
}
