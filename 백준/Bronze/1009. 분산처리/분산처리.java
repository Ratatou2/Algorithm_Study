/*
[백준]
1009, 분산 처리

[문제파악]
- 재용이는 최신 컴퓨터 10대를 가지고 있다.
- 어느 날 재용이는 많은 데이터를 처리해야 될 일이 생겨서 각 컴퓨터에 1번부터 10번까지의 번호를 부여하고, 10대의 컴퓨터가 다음과 같은 방법으로 데이터들을 처리하기로 하였다.
- 1번 데이터는 1번 컴퓨터, 2번 데이터는 2번 컴퓨터, 3번 데이터는 3번 컴퓨터, ... ,
- 10번 데이터는 10번 컴퓨터, 11번 데이터는 1번 컴퓨터, 12번 데이터는 2번 컴퓨터, ...
- 총 데이터의 개수는 항상 a^b개의 형태로 주어진다.
- 재용이는 문득 마지막 데이터가 처리될 컴퓨터의 번호가 궁금해졌다.
- 이를 수행해주는 프로그램을 작성하라.

[입력]
- 입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다.
- 그 다음 줄부터 각각의 테스트 케이스에 대해 정수 a와 b가 주어진다. (1 ≤ a < 100, 1 ≤ b < 1,000,000)

[출력]
- 각 테스트 케이스에 대해 마지막 데이터가 처리되는 컴퓨터의 번호를 출력한다.

[구현방법]
- 브론즈 문제들이 참 좋다고 생각하는게 내가 자주 안쓰는, 혹은 몰랐던 기능들을 써보게 만든다.
- 그런 취지에서 꾸준히 푸는 도전을 할 때 주말 같은 날 간단하게 풀면서도 새로운 지식을 늘게 만드는 문제들이 많아서 좋아함
- 제곱을 구하는건 Math.pow를 쓰면 되지만, 문제 조건상 double의 범위 10의 8제곱을 넘기가 쉽다
- 따로 함수를 만들어야 함
- 그리고 결과값 범위도... int로 하면 21억까진데 그러면 범위를 초과하기 쉽다 (간과했던 부분)
- 함수를 따로 만들고 long으로 계산하는 로직이 필요할듯
- 근데 이거 수학적으로 접근하면 분명 계산을 덜하는 방법이 있을 것이다 (근데 지금은 모르겠음)

[보완점]
- 나는... 쉬운건 너무 어렵게 생각하고, 어려운건 너무 단순하게 생각하는 것 같다
- 이거는 그냥 주기를 구하면 되는 문제였음...
- 각 컴퓨터마다 주기를 구해두면 된다. (N번째 컴퓨터는 몇번 문제를 풀 수 있는지를)
- 즉, 예를들 면 2의 배수들은 2, 4, 6, 8의 컴퓨터에서 문제가 풀릴 수 있다는 것!!
*/

import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws Exception {
        int[][] patterns = {
                {}, // 0
                {1}, // 1
                {2, 4, 8, 6}, // 2
                {3, 9, 7, 1}, // 3
                {4, 6}, // 4
                {5}, // 5
                {6}, // 6
                {7, 9, 3, 1}, // 7
                {8, 4, 2, 6}, // 8
                {9, 1}, // 9
                {10} // 10
        };

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int T = Integer.parseInt(br.readLine());

        while (0 < T--) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken()) % 10;  // 10으로 나눈 나머지
            int b = Integer.parseInt(st.nextToken());

            // (예외처리) 나머지가 0이면, 더 볼 것 없이 10이다
            if (a == 0) {
                System.out.println(10); // 10의 배수는 무조건 10번 컴퓨터
                continue;
            }
            
            int[] pattern = patterns[a];  // 우선 현재 a에서 나올 수 있는, 풀릴 가능성이 있는 컴퓨터들을 찾는다

            int index = (b - 1) % pattern.length;  // 인덱스는 0번부터 시작이니까 b-1, 그리고 b만큼 배열을 돌게되니까 나머지를 구한다
            int result = pattern[index];  // 그럼 이제 인덱스에 해당하는 컴퓨터 번호를 가져오면? 그것이 답이다

            // 10번 컴퓨터는 0으로 나올 수 있으므로 예외처리
            System.out.println(result == 0 ? 10 : result);
        }
    }
}