
/*
[백준]
14890, 경사로

[문제파악]
크기가 N×N인 지도가 있다. 지도의 각 칸에는 그 곳의 높이가 적혀져 있다.
오늘은 이 지도에서 지나갈 수 있는 길이 몇 개 있는지 알아보려고 한다.
길이란 한 행 또는 한 열 전부를 나타내며, 한쪽 끝에서 다른쪽 끝까지 지나가는 것이다.
다음과 같은 N=6인 경우 지도를 살펴보자.

이때, 길은 총 2N개가 있으며, 아래와 같다.

길을 지나갈 수 있으려면 길에 속한 모든 칸의 높이가 모두 같아야 한다. 또는, 경사로를 놓아서 지나갈 수 있는 길을 만들 수 있다.
경사로는 높이가 항상 1이며, 길이는 L이다. 또, 개수는 매우 많아 부족할 일이 없다.
경사로는 낮은 칸과 높은 칸을 연결하며, 아래와 같은 조건을 만족해야한다.

경사로는 낮은 칸에 놓으며, L개의 연속된 칸에 경사로의 바닥이 모두 접해야 한다.
낮은 칸과 높은 칸의 높이 차이는 1이어야 한다.
경사로를 놓을 낮은 칸의 높이는 모두 같아야 하고, L개의 칸이 연속되어 있어야 한다.
아래와 같은 경우에는 경사로를 놓을 수 없다.

경사로를 놓은 곳에 또 경사로를 놓는 경우
낮은 칸과 높은 칸의 높이 차이가 1이 아닌 경우
낮은 지점의 칸의 높이가 모두 같지 않거나, L개가 연속되지 않은 경우
경사로를 놓다가 범위를 벗어나는 경우
L = 2인 경우에 경사로를 놓을 수 있는 경우를 그림으로 나타내면 아래와 같다.

경사로를 놓을 수 없는 경우는 아래와 같다.

위의 그림의 가장 왼쪽부터 1번, 2번, 3번, 4번 예제라고 했을 때, 1번은 높이 차이가 1이 아니라서, 2번은 경사로를 바닥과 접하게 놓지 않아서, 3번은 겹쳐서 놓아서, 4번은 기울이게 놓아서 불가능한 경우이다.
가장 위에 주어진 그림 예의 경우에 지나갈 수 있는 길은 파란색으로, 지나갈 수 없는 길은 빨간색으로 표시되어 있으며, 아래와 같다.
경사로의 길이 L = 2이다.

지도가 주어졌을 때, 지나갈 수 있는 길의 개수를 구하는 프로그램을 작성하시오.

[입력]
첫째 줄에 N (2 ≤ N ≤ 100)과 L (1 ≤ L ≤ N)이 주어진다.
둘째 줄부터 N개의 줄에 지도가 주어진다.
각 칸의 높이는 10보다 작거나 같은 자연수이다.

[출력]
첫째 줄에 지나갈 수 있는 길의 개수를 출력한다.

[구현방법]
- 찐 구현문제
- 한줄씩 탐색하면 된다 (2초 제한에 N은 최대 100이니까 한줄씩 전체 탐색해도? 2N^2(= O(N^2) = 10,000)이니까 안전범위)
- 경사로를 놓기 위해선 L길이가 필요하고 높이가 1이니까 늘 낮은쪽이든 높은 쪽이든 카운트를 해야한다
    - 예를들어 2-2-2-1-1-1이고, L=2이면?
        - 2에서 1로 내려갈 때 경사로가 필요하고, 2->1 지점의 높이 차이가 1이면 가능 (첫번째 조건)
        - 두번째로 1이 최소한 L인 2만큼 있어야 경사로를 둘 수 있다 (두번째 조건)
    - 반대로 1-1-1-2-2-2이고, L=2이면?
        - 1에서 2로 올라갈 때 경사로가 필요하고, 1->2 지점의 높이 차이가 1이면 가능 (첫번째 조건)
        - 두번째로 1이 최소한 L인 2만큼 있어야 경사로를 둘 수 있다 (두번째 조건)
    - 요지는 아래 두가지 조건을 확인해야한다
        1) 높이가 바뀌는 지점인 경우, 그 높이 차이가 1인지 (아니라면 불가한 경우이므로 break;)
        2) 경사로를 설치해야하는 쪽이 L의 길이만큼 여유가 있는지 체크 필요
            - 다만 이 경우엔 이전 단계부터 카운트하면서 오는게 좋다 (괜히 또 탐색을 해야하는 경우가 생기면 최악의 경우 O^3에 근접할 수 있기 떄문에
- 그렇다면 아직 명확하지 않은 부분은 '낮은 -> 높은' 으로 이동할 때야 이전 높이를 카운트를 하면서 진행하면 된다
- '높은 -> 낮은'인 경우는? flag(boolean)을 하나 만들어서 낮은 쪽으로 이동한 경우 낮은게 L만큼 존재하는지 카운트하면 되지 않나? (더 효율적인 방법은 없나?)
    - 이 부분을 고민하면서 내가 놓친게 두가지 있음
        1) '높은 -> 낮은'이 되는 순간 앞의 L칸을 미리 탐색해서 설치 가능 여부를 판단하는 것
            - 이걸 미리 하고나면 추가 탐색을 그만둘지 아닐지 빠르게 확인할 수 있다
            - 다만 유의해야할 점은 탐색을 통해 L의 길이를 확보했다고 하더라도, 확보된 길이를 건너뛰면 안된다는 것 (탐색하던 지점부터 계속해야한다)
            - 왜냐면 그 다음 경사로 설치에 필요한 정보를 가지고 있기 때문이다 (낮은 -> 높은이 되는 지점을 만나면 '이전 같은 높이의 갯수'가 확인되어야 한다
        2) 경사로를 설치하는데 사용처리한 배열이 필요하다는 것(isUsed)
            - 왜냐면 경사로는 겹쳐서 설치가 불가능하기 때문이다
            - 이전에 설치한 것 때문에 다음 경사로를 설치 불가능하다면 그 행 or 열은 '건너는 것이 불가능' 해진다
- 주의할 점 두가지
    1) 경사로가 map의 경계(범위)를 벗어나지 않는지 체크
    2) isUsed는 new boolean[N]이면 충분하다
        - 해당 행, 열을 '건널 수 있는가'가 핵심이다
        - 이번 열에 설치했다고 겹치는 행을 못 건너는게 아니기 때문

[보완점]
- 행, 열을 나눌 때 함수의 변수를 좀 더 줄이고 내부식에서 유연하게 대처하는 것이 좀 더 가독성도, 사용하기도 좋은 코드가 된다
- 특히 경사로를 설치할 수 있는지 확인하는 것보다, 경로 전체를 확인하며 체크하는 로직까지 내포하는 것이 좀 더 깔끔했다
- 구현문제는 좀 더 치밀하게, 세세한 그물 짜듯이 짠 다음 코드를 짜는 것이 낫다 ㅠ
*/

import java.io.*;
import java.util.*;

public class Main {
    static int N, L, count;
    static int[][] map;
    static boolean[] isUsed;

    // 현재의 행, 열이 건널 수 있는지 체크
    static boolean checkPath(int index, boolean isRow) {
        int[] line = new int[N];
        boolean[] isUsed = new boolean[N];

        // isRow라는 flag로 현재의 행 or 열을 복사해서 가져온다
        for (int i = 0; i < N; i++) {
            line[i] = isRow ? map[index][i] : map[i][index];
        }

        for (int i = 0; i < N - 1; i++) {
            int curr = line[i];         // 현재 높이
            int next = line[i + 1];     // 다음 높이

            // 현재랑 다음 높이가 같으면 더 볼 것 없이 다음으로 진행
            if (curr == next) continue;

            // 다르다면 그 차이값(diff)을 구한다
            int diff = curr - next;

            // 높이 차이 1 초과 → 경사로 설치 불가
            if (Math.abs(diff) != 1) return false;

            if (diff == -1) {   // 현재 위치가 다음 이동할 위치보다 낮다면? (낮 -> 높 : 오르막의 경사로를 만들어야 함)
                // 이전의 L칸을 확인해야 한다
                for (int j = i; i - L < j; j--) {
                    // j가 0보다 크면서, 현재의 높이와 같고, 사용한 적도 없어야만 한다 (범위 밖으로 나가지 않았고, 경사로를 설치할 수 있게 L칸을 보유하고 있으며, 해당 위치에 경사로를 둔 적이 없어야만 경사로 설치가 가능하다는 문제조건)
                    if (j < 0 || line[j] != curr || isUsed[j]) return false;
                    isUsed[j] = true;  // 경사로를 설치했으니까 사용처리해둔다
                }
            } else {    // 현재의 위치가 다음 이동할 위치보다 높다면? (높 -> 낮 : 내리막의 경사로를 만들어야 함)
                // 이후의 L칸을 확인해야 한다
                for (int j = i + 1; j <= i + L; j++) {
                    // j가 N보다 작으면서, 다음 높이와 같으며, 사용한적도 없어야만 한다 (위와 동일한 설명)
                    if (N <= j || line[j] != next || isUsed[j]) return false;
                    isUsed[j] = true;  // 경사로를 설치했으니까 사용처리해둔다
                }

                i += L - 1; // 내리막 구간은 건너뛰기 (이미 else에 들어온 순간부터 현 i 이후의 L칸만큼의 isUsed들은 방문처리가 되어있으니 넘어가도 된다)
            }
        }

        return true;
    }


    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        // N과 L 입력받기
        N = Integer.parseInt(st.nextToken());
        L = Integer.parseInt(st.nextToken());

        map = new int[N][N];
        isUsed = new boolean[N];
        count = 0;

        // Map 입력 받기
        for (int row = 0; row < N; row++) {
            st = new StringTokenizer(br.readLine());

            for (int col = 0; col < N; col++) {
                map[row][col] = Integer.parseInt(st.nextToken());
            }
        }

        for (int i = 0; i < N; i++) {
            if (checkPath(i, true)) count++;    // 행 탐색
            if (checkPath(i, false)) count++;   // 열 탐색
        }

        System.out.println(count);
    }
}