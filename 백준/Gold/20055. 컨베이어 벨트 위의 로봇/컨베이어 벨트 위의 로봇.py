"""
[백준] 20055, 컨베이어 벨트 위의 로봇
(https://www.acmicpc.net/problem/20055)

[문제파악]
- '올리는 위치' : 1번칸이 있는 위치
- '내리는 위치' : N번 칸이 있는 위치

1. 길이가 N인 컨베이어 벨트 존재
2. 길이가 2N인 벨트가 이 벨트를 위 아래로 감싸며 돌고 있음
3. 벨트는 길이 1 간격으로 2N의 칸으로 나뉘어 있음
4. 벨트가 한칸 회전하면,
    1) 1번부터 2N-1번까지의 칸 : 다음 번호의 칸이 있는 위치로 이동
    2) 2N번칸 : 1번 칸으로 이동

5. 컨베이어 벨트에 박스 모양 로봇을 하나씩 올림
6. 로봇은 올리는 위치에만 올릴 수 있음
7. 언제든 로봇이 내리는 위치에 도달하면 그 즉시 내림
8. 로봇은 컨베이어 벨트 위에서 스스로 이동 가능
9. 칸의 내구도가 감소하는 케이스
    1) 로봇을 올리는 위치에 올림
    2) 로봇이 어떤 칸으로 이동함

- 플로우
1) 벨트 회전 (로봇과 함께 회전함)
2) (가장 먼저에 벨트에 올라간 로봇부터) 로봇은 벨트가 회전하는 방향으로
    (1) 한칸 이동 가능하다면 이동한다
    (2) 이동할 수 없다면, 가만히 있는다
3) 단, 이동하려면 이동하려는 칸에 로봇이 없으며, 내구도가 1이상 남아있어야 한다
4) 올리는 칸의 내구도가 0이 아니라면, 올리는 위치에 로봇을 올린다
5) 내구도가 0인 칸의 갯수가 K개 이상이라면 종료
    - 아니라면 1번으로 돌아가 반복

- 종료되었을 때, 몇번째 단계가 진행 중이었는지 구할 것 (가장 처음 수행되는 단계는 1단계)


[입력]
1. 첫줄에 N, K
2. 둘쨋줄에 A1 ~ A2N이 주어짐 (벨트)


[구현방법]
1. 일단 벨트 이동하는거 구현해놓고
2. 로봇 이동하는거 구현해놓고
3. 조건 맞춰서 이동한다
4. 참 쉽죠?

- 1시간 소요
1. 응 못 풀었어~
2. 알고보니 파이썬 deque에는 rotate라는게 있단다 (이거 도라이 기능이네;;)

- 무엇을 위한 1시간이었나
- 반.드.시. 다시 풀어볼 것
- 대신 라이브러리 쓰지말고 순수 구현으로


[보완점]
- 구현 그냥 구현 빡빡빡구현

"""

from collections import deque

N, K = map(int, input().split())
durability = deque(map(int, input().split()))  # 내구도
robot = deque([0] * N)  # 벨트 위 로봇
result = 0

while True:
    result += 1
    durability.rotate(1)  # 내구도 한바퀴 돌려
    # 한바퀴 돌렸으니, N위치에 있는 로봇은 1로 이동해야한다
    # 이 말인 즉슨 내리라는 것
    robot[-1] = 0

    # 마찬가지로 로봇 한바퀴 돌려
    robot.rotate(1)
    robot[-1] = 0  # 눈치껏 내려야겠지?

    # 이제 올라가 있는 로봇들 한칸씩 이동할 예정
    # 먼저 올라간 로봇부터 진행해야 함
    # 그러니까 큰 것(N-2)부터 시작하고, 거기서 -1 진행 (나중에 올라간 애들)
    for i in range(N-2, -1, -1):
        # 현재 칸에 로봇이 있고, 다음 칸에 로봇 없고, 이동할 위치에 내구도 1 이상 남아있다면 이동!
        if robot[i] == 1 and robot[i+1] == 0 and 1 <= durability[i+1]:
            robot[i+1] = 1  # 현재 칸 로봇 이동
            robot[i] = 0  # 로봇 이동했으니 자리 비워
            durability[i+1] -= 1  # 이동한 곳 내구도 떨궈

    robot[-1] = 0  # 내려야지?

    # 내구도 0아니고, 로봇있는게 아니라면
    if durability[0] != 0 and robot[0] != 1:
        robot[0] = 1  # 로봇 올려!
        durability[0] -= 1  # 내구도 떨궈!

    # 내구도 갯수가 K개 이상이면 멈춰야겠지?
    if K <= durability.count(0):
        break

print(result)